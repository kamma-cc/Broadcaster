# Broadcaster 协议设计

## 问题描述

### 挑战：TCP 广播中的流中途加入

**场景：**
- **发送方**：持续向 TCP socket 写入消息，一条接一条无脑发送
- **接收方**：可以随时加入，从 TCP 流的中间位置开始接收数据
- **核心问题**：TCP 是无边界的流式协议

**核心问题：**
如何设计应用层协议，使得在流中途加入的接收方能够识别消息边界？

### 关键需求

1. **任意加入点**：客户端必须能在流的任意字节位置加入并实现同步
2. **边界检测**：即使没有看到流的起点，也能清晰识别消息边界
3. **最小延迟**：同步应尽可能快速完成
4. **可靠性**：检测边界时误判率要低
5. **性能**：CPU 和带宽开销要最小

---

## 协议方案：COBS 编码（一致性开销字节填充）

### 核心思想

COBS（Consistent Overhead Byte Stuffing）的核心思想是：**使用特殊字节 0x00 作为帧分隔符，同时将消息体中所有的 0x00 字节通过编码消除掉**。

这样，0x00 在整个流中只会出现在消息边界，永远不会出现在消息内容中。

### 协议格式

消息流的格式非常简单：

```
[0x00][编码后的消息1][0x00][编码后的消息2][0x00][编码后的消息3][0x00]...
```

每条消息被 0x00 字节包围，形成清晰的边界。

### 编码原理

COBS 编码将原始消息转换成不包含任何 0x00 字节的编码形式。编码过程遵循以下规则：

1. **查找 0x00 位置**：扫描原始消息，找到所有 0x00 字节的位置，将消息分成多个段

2. **每段添加长度信息**：在每个段的开头插入一个"代码字节"，表示"从这里到下一个原始 0x00 的距离（字节数）+ 1"

3. **处理长段**：如果某段连续 254 个字节都没有 0x00，就在第 254 字节处强制插入一个代码字节 0xFF，表示"接下来 254 字节没有 0x00"

4. **代码字节范围**：代码字节的取值范围是 1-255（0x01-0xFF），永远不会是 0x00

### 编码示例

**示例 1：包含一个 0x00**
- 原始消息：`[0x01, 0x00, 0x02, 0x03]`
- 分段：第一段 `[0x01]`，第二段 `[0x02, 0x03]`
- 编码结果：`[0x02, 0x01, 0x03, 0x02, 0x03]`
  - `0x02`：表示距离下一个原始 0x00 有 2 字节
  - `0x01`：第一段的数据
  - `0x03`：表示距离消息结束有 3 字节
  - `0x02, 0x03`：第二段的数据
- 成帧：`[0x00][0x02, 0x01, 0x03, 0x02, 0x03][0x00]`

**示例 2：不包含 0x00**
- 原始消息：`[0x01, 0x02, 0x03]`
- 编码结果：`[0x04, 0x01, 0x02, 0x03]`
  - `0x04`：表示整个消息 4 字节（3 字节数据 + 1）没有 0x00
- 成帧：`[0x00][0x04, 0x01, 0x02, 0x03][0x00]`

**示例 3：包含多个连续 0x00**
- 原始消息：`[0x11, 0x00, 0x00, 0x22]`
- 编码结果：`[0x02, 0x11, 0x01, 0x02, 0x22]`
  - `0x02`：距离第一个 0x00 有 2 字节
  - `0x11`：第一段数据
  - `0x01`：空段（两个 0x00 之间没有数据）
  - `0x02`：距离消息结束有 2 字节
  - `0x22`：最后一段数据
- 成帧：`[0x00][0x02, 0x11, 0x01, 0x02, 0x22][0x00]`

### 关键特性

**为什么编码后不含 0x00？**

编码后的消息只包含两种字节：
1. **代码字节**：取值 1-255，永远不是 0
2. **原始数据的非零字节**：这些字节本来就不是 0

因此，编码结果中不可能出现 0x00，所以可以安全地使用 0x00 作为帧分隔符。

### 同步机制

**新客户端加入流程：**

1. **扫描分隔符**：客户端从流的任意位置开始，逐字节读取，直到遇到第一个 0x00 字节

2. **即时同步**：找到 0x00 后，客户端立即知道下一个字节是新消息的开始，同步完成

3. **正常接收**：从此开始，客户端按照"读取到 0x00 → 解码 → 处理消息"的循环工作

**同步特点：**
- **即时性**：最多丢弃一条不完整的消息，立即在下一个消息边界同步
- **确定性**：0x00 天然保证是边界，不存在误判
- **无需验证**：不需要校验和、魔数等额外验证

### 解码过程

接收方收到编码后的消息后，按照以下步骤解码：

1. **读取代码字节**：获取距离信息

2. **复制数据**：复制接下来（代码 - 1）个字节到输出

3. **插入 0x00**：如果代码字节不是 0xFF 且不是最后一段，在输出中插入一个 0x00

4. **重复**：继续处理下一段，直到消息结束

### 性能分析

**带宽开销：**
- 最佳情况（无 0x00）：每 254 字节增加 1 字节 = 0.4% 开销
- 最坏情况（全是 0x00）：每字节变 2 字节 = 100% 开销
- 典型情况（随机数据）：约 0.4-1% 开销

**CPU 开销：**
- 编码/解码都是单次遍历，时间复杂度 O(n)
- 无需复杂计算（如 CRC32）
- 非常高效

**同步性能：**
- 同步时间：扫描到下一个 0x00 即可，通常小于一条消息的长度
- 同步可靠性：100%（0x00 不可能出现在消息中）

### 适用场景

COBS 协议特别适合以下场景：

- **高频客户端加入**：客户端随时加入、离开、重连
- **实时性要求高**：需要快速同步到消息流
- **带宽敏感**：相比其他方案，开销最小
- **高性能广播**：适合一对多的广播场景
- **嵌入式系统**：编解码简单，内存占用小

### 优势总结

1. ⭐ **即时同步**：客户端在流中任意位置加入，扫描到下一个 0x00 立即同步，无需等待特殊同步帧

2. ⭐ **零误判**：0x00 绝对是边界，不存在假阳性的可能

3. ⭐ **最小开销**：平均带宽开销仅 0.4%，远低于其他方案

4. ⭐ **实现简单**：编解码逻辑清晰，代码量小（约 100 行）

5. ⭐ **确定性强**：行为完全可预测，便于测试和调试

6. ⭐ **高性能**：单次遍历，无需复杂计算，CPU 开销极低

### 潜在限制

1. **消息膨胀**：在极端情况下（消息全是 0x00），会导致 100% 的膨胀，但这种情况在实际应用中极少出现

2. **无元数据**：COBS 本身不携带序列号、时间戳等元数据，如需这些信息，需要在应用层自行添加

3. **二进制依赖**：必须保证传输过程不会篡改字节（通常不是问题，TCP 本身就是可靠的字节流）

---

## 参考资料

**COBS 原始论文：**
"Consistent Overhead Byte Stuffing" by Stuart Cheshire and Mary Baker

**实际应用：**
- 嵌入式系统中的串行通信协议
- 工业控制总线协议
- 传感器网络数据传输

**相关概念：**
- 字节填充（Byte Stuffing）
- 帧同步（Frame Synchronization）
- 零拷贝传输（Zero-copy Transmission）